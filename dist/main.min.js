(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("dollarSigns", [], factory);
	else if(typeof exports === 'object')
		exports["dollarSigns"] = factory();
	else
		root["dollarSigns"] = factory();
})(global, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it uses a non-standard name for the exports (exports).
(() => {
var exports = __webpack_exports__;
/*!***************************!*\
  !*** ./src/twodollars.ts ***!
  \***************************/

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.twoDollars = void 0;
const d = document;
const dp = new DOMParser();
const twoDollars = {
    create: (element, attributes) => {
        const $element = d.createElement(element.slice(1, -2));
        attributes &&
            Object.keys(attributes).forEach((key) => $element.setAttribute(key, attributes[key]));
        return $element;
    },
    find: (selector, target = document.documentElement) => Array.from(target.querySelectorAll(selector)) || [document.documentElement],
    append: (toAppend, target) => {
        target.appendChild(toAppend);
        return twoDollars;
    },
    measure: (str, fontSize) => {
        const $helper = twoDollars.create("<span/>", { innerText: str });
        twoDollars.css($helper, {
            position: "absolute",
            left: "-9999px",
            top: "-9999px",
        });
        fontSize && twoDollars.css($helper, { fontSize: `${fontSize}px` });
        document.body.appendChild($helper);
        const measures = {
            h: $helper.clientHeight,
            w: $helper.clientWidth,
        };
        document.body.removeChild($helper);
        return measures;
    },
    parse: (str) => dp.parseFromString(str, "text/html"),
    css: ($element, props) => {
        props &&
            Object.keys(props).forEach((key) => $element.style.setProperty(key, props[key]));
        return twoDollars;
    },
    parent: ($element, selector) => {
        if (!selector)
            return $element.parentNode;
        const selectorMatch = ($elm, sel) => $elm.matches(sel)
            ? $elm
            : selectorMatch($elm.parentNode, sel);
        return selectorMatch($element.parentNode, selector);
    },
    hasClass: (element, cn) => element.classList.contains(cn),
    addClass: (element, cn) => {
        !element.classList.contains(cn) && element.classList.add(cn);
        return twoDollars;
    },
    removeClass: (element, cn) => {
        element.classList.contains(cn) && element.classList.remove(cn);
        return twoDollars;
    },
    toggleClass: (element, cn) => {
        element.classList.toggle(cn);
        return twoDollars;
    },
    addAttr: (element, attributes) => {
        attributes &&
            Object.keys(attributes).forEach((key) => element.setAttribute(key, attributes[key]));
        return twoDollars;
    },
    ucFirst: (str) => str.charAt(0).toUpperCase() + str.slice(1),
    extend: (target, extension = {}) => {
        Object.keys(extension).forEach((key) => (target[key] = extension[key]));
        return target;
    },
    index: ($element) => {
        const $parent = $element.parentNode;
        return Array.prototype.indexOf.call($parent.childNodes, $element);
    },
    listen: (event) => {
        const { handler, target, type } = event;
        target.addEventListener(type, handler);
        return twoDollars;
    },
    destroy: (event) => {
        const { handler, target, type } = event;
        if (handler)
            target.removeEventListener(type, handler);
        return twoDollars;
    },
    post: (url, data) => {
        return new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();
            xhr.open("POST", url, true);
            xhr.setRequestHeader("Content-Type", "application/json");
            xhr.send(JSON.stringify(data));
            xhr.onload = () => resolve(xhr.responseText);
            xhr.onerror = (error) => reject(error);
        });
    },
    preload: (opt) => {
        const { items, onFileLoaded, onFinish } = opt;
        const toLoad = items.length;
        const supported = ["jpg", "png"];
        let loaded = 0;
        items.forEach((item) => {
            const type = item.split(".").pop();
            if (type && supported.indexOf(type) === -1)
                return;
            const img = new Image();
            img.onload = () => {
                if (++loaded === toLoad)
                    onFinish(toLoad);
                else
                    onFileLoaded(img.getAttribute("src") || "");
            };
            img.src = item;
        });
    },
    history: {
        go: (name, path) => window.history.pushState({ site: name }, "", path),
    },
};
exports.twoDollars = twoDollars;

})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=main.min.js.map